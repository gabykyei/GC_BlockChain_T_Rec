{"name":"node-cbor","tagline":"Encode and decode CBOR documents, with both easy mode, streaming mode, and SAX-style evented mode.","body":"Installation:\r\n\r\n```\r\n$ npm install node-cbor\r\n```\r\n\r\nFrom the command line:\r\n```\r\n$ bin/json2cbor package.json > package.cbor\r\n$ bin/cbor2json package.cbor\r\n$ bin/cbor2diag package.cbor\r\n```\r\n\r\nExample:\r\n```javascript\r\nvar cbor = require('node-cbor');\r\nvar encoded = cbor.encode(true); // returns <Buffer d9>\r\ncbor.decode(encoded, function(error, obj) {\r\n  // error != null if there was an error\r\n  // obj is the unpacked object\r\n  assert.ok(obj === true);\r\n});\r\n```\r\n\r\nAllows streaming as well:\r\n\r\n```javascript\r\nvar cbor = require('node-cbor');\r\nvar fs = require('fs');\r\n\r\nvar d = new cbor.Decoder();\r\nd.on('complete', function(obj){\r\n  console.log(obj);\r\n});\r\n\r\nvar s = fs.createReadStream('foo');\r\ns.pipe(d);\r\n\r\nvar d2 = new cbor.Decoder({input: '00', encoding: 'hex'});\r\nd.on('complete', function(obj){\r\n  console.log(obj);\r\n});\r\nd2.start(); // needed when you don't use the stream interface\r\n```\r\n\r\nAnd also a SAX-type mode (which the streaming mode wraps):\r\n\r\n```javascript\r\nvar cbor = require('node-cbor');\r\nvar fs = require('fs');\r\n\r\nvar parser = new cbor.Evented();\r\n\r\n// `kind` is one of the following strings:\r\n// 'value': an atomic value was detected\r\n// 'array-first': the first element of an array\r\n// 'array': an item after the first in an array\r\n// 'key-first': the first key in a map\r\n// 'key': a key other than the first in a map\r\n// 'stream-first': the first item in an indefinite encoding\r\n// 'stream': an item other than the first in an indefinite encoding\r\n// null: the end of a top-level CBOR item\r\n\r\nparser.on('value',function(val,tags,kind) {\r\n  // An atomic item (not a map or array) was detected\r\n  // `val`: the value\r\n  // `tags`: an array of tags that preceded the list\r\n  // `kind`: see above\r\n  console.log(val);\r\n});\r\nparser.on('array-start', function(count,tags,kind) {\r\n  // `count`: The number of items in the array.  -1 if indefinite length.\r\n  // `tags`: An array of tags that preceded the list\r\n  // `kind`: see above\r\n});\r\nparser.on('array-stop', function(count,tags,kind) {\r\n  // `count`: The actual number of items in the array.\r\n  // `tags`: An array of tags that preceded the list\r\n  // `kind`: see above\r\n});\r\nparser.on('map-start', function(count,tags,kind) {\r\n  // `count`: The number of pairs in the map.  -1 if indefinite length.\r\n  // `tags`: An array of tags that preceded the list\r\n  // `kind`: see above\r\n});\r\nparser.on('map-stop', function(count,tags,kind) {\r\n  // `count`: The actual number of pairs in the map.\r\n  // `tags`: An array of tags that preceded the list\r\n  // `kind`: see above\r\n});\r\nparser.on('stream-start', function(mt,tags,kind) {\r\n  // The start of a CBOR indefinite length bytestring or utf8-string.\r\n  // `mt`: The major type for all of the items\r\n  // `tags`: An array of tags that preceded the list\r\n  // `kind`: see above\r\n});\r\nparser.on('stream-stop', function(count,mt,tags,kind) {\r\n  // We got to the end of a CBOR indefinite length bytestring or utf8-string.\r\n  // `count`: The number of constituent items\r\n  // `mt`: The major type for all of the items\r\n  // `tags`: An array of tags that preceded the list\r\n  // `kind`: see above\r\n});\r\nparser.on('end', function() {\r\n  // the end of the input\r\n});\r\nparser.on('error', function(er) {\r\n  // parse error such as invalid input\r\n});\r\n\r\nvar s = fs.createReadStream('foo');\r\ns.pipe(parser);\r\n```\r\n\r\nTest coverage is currently above 95%.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}