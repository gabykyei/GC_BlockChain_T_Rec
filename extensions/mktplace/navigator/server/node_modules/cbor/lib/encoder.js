// Generated by CoffeeScript 1.10.0
(function() {
  var DOUBLE, Encoder, FALSE, MAXINT_BN, MT, NULL, NUMBYTES, NoFilter, SHIFT32, SIMPLE, SYMS, Simple, TAG, TRUE, Tagged, UNDEFINED, bignumber, ref, stream, url,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  stream = require('stream');

  url = require('url');

  bignumber = require('bignumber.js');

  NoFilter = require('nofilter');

  Tagged = require('./tagged');

  Simple = require('./simple');

  ref = require('./constants'), MT = ref.MT, NUMBYTES = ref.NUMBYTES, TAG = ref.TAG, SIMPLE = ref.SIMPLE, SYMS = ref.SYMS;

  SHIFT32 = Math.pow(2, 32);

  DOUBLE = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.EIGHT;

  TRUE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.TRUE;

  FALSE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.FALSE;

  UNDEFINED = (MT.SIMPLE_FLOAT << 5) | SIMPLE.UNDEFINED;

  NULL = (MT.SIMPLE_FLOAT << 5) | SIMPLE.NULL;

  MAXINT_BN = new bignumber('0x20000000000000');

  module.exports = Encoder = (function(superClass) {
    extend(Encoder, superClass);

    function Encoder(options) {
      var addTypes, i, j, len1, ref1, typ;
      if (options == null) {
        options = {};
      }
      options.readableObjectMode = false;
      options.writableObjectMode = true;
      Encoder.__super__.constructor.call(this, options);
      this.semanticTypes = [Array, this._pushArray, Date, this._pushDate, Buffer, this._pushBuffer, Map, this._pushMap, NoFilter, this._pushNoFilter, RegExp, this._pushRegexp, Set, this._pushSet, url.Url, this._pushUrl, bignumber, this._pushBigNumber];
      addTypes = (ref1 = options.genTypes) != null ? ref1 : [];
      for (i = j = 0, len1 = addTypes.length; j < len1; i = j += 2) {
        typ = addTypes[i];
        this.addSemanticType(typ, addTypes[i + 1]);
      }
    }

    Encoder.prototype._transform = function(fresh, encoding, cb) {
      this._pushAny(fresh);
      return cb();
    };

    Encoder.prototype._flush = function(cb) {
      return cb();
    };

    Encoder.prototype.addSemanticType = function(type, fun) {
      var i, j, len1, old, ref1, ref2, typ;
      ref1 = this.semanticTypes;
      for (i = j = 0, len1 = ref1.length; j < len1; i = j += 2) {
        typ = ref1[i];
        if (typ === type) {
          ref2 = [this.semanticTypes[i + 1], fun], old = ref2[0], this.semanticTypes[i + 1] = ref2[1];
          return old;
        }
      }
      this.semanticTypes.push(type, fun);
      return null;
    };

    Encoder._push_gen = function(meth, len) {
      return function(val) {
        var b;
        b = new Buffer(len);
        b[meth].call(b, val, 0);
        return this.push(b);
      };
    };

    Encoder.prototype._pushInt8 = Encoder._push_gen('writeInt8', 1);

    Encoder.prototype._pushUInt8 = Encoder._push_gen('writeUInt8', 1);

    Encoder.prototype._pushInt16BE = Encoder._push_gen('writeInt16BE', 2);

    Encoder.prototype._pushUInt16BE = Encoder._push_gen('writeUInt16BE', 2);

    Encoder.prototype._pushInt32BE = Encoder._push_gen('writeInt32BE', 4);

    Encoder.prototype._pushUInt32BE = Encoder._push_gen('writeUInt32BE', 4);

    Encoder.prototype._pushFloatBE = Encoder._push_gen('writeFloatBE', 4);

    Encoder.prototype._pushDoubleBE = Encoder._push_gen('writeDoubleBE', 8);

    Encoder.prototype._pushNaN = function() {
      return this.push('f97e00', 'hex');
    };

    Encoder.prototype._pushInfinity = function(obj) {
      var half;
      half = obj < 0 ? 'f9fc00' : 'f97c00';
      return this.push(half, 'hex');
    };

    Encoder.prototype._pushFloat = function(obj) {
      this._pushUInt8(DOUBLE);
      return this._pushDoubleBE(obj);
    };

    Encoder.prototype._pushInt = function(obj, mt, orig) {
      var m;
      m = mt << 5;
      switch (false) {
        case !(obj < 24):
          return this._pushUInt8(m | obj);
        case !(obj <= 0xff):
          this._pushUInt8(m | NUMBYTES.ONE);
          return this._pushUInt8(obj);
        case !(obj <= 0xffff):
          this._pushUInt8(m | NUMBYTES.TWO);
          return this._pushUInt16BE(obj);
        case !(obj <= 0xffffffff):
          this._pushUInt8(m | NUMBYTES.FOUR);
          return this._pushUInt32BE(obj);
        case !(obj <= Number.MAX_SAFE_INTEGER):
          this._pushUInt8(m | NUMBYTES.EIGHT);
          this._pushUInt32BE(Math.floor(obj / SHIFT32));
          return this._pushUInt32BE(obj % SHIFT32);
        default:
          if (mt === MT.NEG_INT) {
            return this._pushFloat(orig);
          } else {
            return this._pushFloat(obj);
          }
      }
    };

    Encoder.prototype._pushIntNum = function(obj) {
      if (obj < 0) {
        return this._pushInt(-obj - 1, MT.NEG_INT, obj);
      } else {
        return this._pushInt(obj, MT.POS_INT);
      }
    };

    Encoder.prototype._pushNumber = function(obj) {
      switch (false) {
        case !isNaN(obj):
          return this._pushNaN(obj);
        case !!isFinite(obj):
          return this._pushInfinity(obj);
        case Math.round(obj) !== obj:
          return this._pushIntNum(obj);
        default:
          return this._pushFloat(obj);
      }
    };

    Encoder.prototype._pushString = function(obj) {
      var len;
      len = Buffer.byteLength(obj, 'utf8');
      this._pushInt(len, MT.UTF8_STRING);
      return this.push(obj, 'utf8');
    };

    Encoder.prototype._pushBoolean = function(obj) {
      return this._pushUInt8(obj ? TRUE : FALSE);
    };

    Encoder.prototype._pushUndefined = function(obj) {
      return this._pushUInt8(UNDEFINED);
    };

    Encoder.prototype._pushArray = function(gen, obj) {
      var j, len, len1, results, x;
      len = obj.length;
      this._pushInt(len, MT.ARRAY);
      results = [];
      for (j = 0, len1 = obj.length; j < len1; j++) {
        x = obj[j];
        results.push(this._pushAny(x));
      }
      return results;
    };

    Encoder.prototype._pushTag = function(tag) {
      return this._pushInt(tag, MT.TAG);
    };

    Encoder.prototype._pushDate = function(gen, obj) {
      this._pushTag(TAG.DATE_EPOCH);
      return this._pushAny(obj / 1000);
    };

    Encoder.prototype._pushBuffer = function(gen, obj) {
      this._pushInt(obj.length, MT.BYTE_STRING);
      return this.push(obj);
    };

    Encoder.prototype._pushNoFilter = function(gen, obj) {
      return this._pushBuffer(gen, obj.slice());
    };

    Encoder.prototype._pushRegexp = function(gen, obj) {
      this._pushTag(TAG.REGEXP);
      return this._pushAny(obj.source);
    };

    Encoder.prototype._pushSet = function(gen, obj) {
      gen._pushInt(obj.size, MT.ARRAY);
      return obj.forEach(function(x) {
        return gen._pushAny(x);
      });
    };

    Encoder.prototype._pushUrl = function(gen, obj) {
      this._pushTag(TAG.URI);
      return this._pushAny(obj.format());
    };

    Encoder.prototype._pushBigint = function(obj) {
      var buf, str, tag;
      if (obj.isNegative()) {
        obj = obj.negated().minus(1);
        tag = TAG.NEG_BIGINT;
      } else {
        tag = TAG.POS_BIGINT;
      }
      str = obj.toString(16);
      if (str.length % 2) {
        str = '0' + str;
      }
      buf = new Buffer(str, 'hex');
      this._pushTag(tag);
      return this._pushBuffer(this, buf, this.bs);
    };

    Encoder.prototype._pushBigNumber = function(gen, obj) {
      var dec, slide;
      if (obj.isNaN()) {
        return this._pushNaN();
      }
      if (!obj.isFinite()) {
        return this._pushInfinity(obj.isNegative() ? -Infinity : Infinity);
      }
      if (obj.isInteger()) {
        return this._pushBigint(obj);
      }
      this._pushTag(TAG.DECIMAL_FRAC);
      this._pushInt(2, MT.ARRAY);
      dec = obj.decimalPlaces();
      slide = obj.mul(new bignumber(10).pow(dec));
      this._pushIntNum(-dec);
      if (slide.abs().lessThan(MAXINT_BN)) {
        return this._pushIntNum(slide.toNumber());
      } else {
        return this._pushBigint(slide);
      }
    };

    Encoder.prototype._pushMap = function(gen, obj) {
      gen._pushInt(obj.size, MT.MAP);
      return obj.forEach(function(v, k) {
        gen._pushAny(k);
        return gen._pushAny(v);
      });
    };

    Encoder.prototype._pushObject = function(obj) {
      var f, i, j, k, keys, l, len1, len2, ref1, results, typ;
      if (!obj) {
        return this._pushUInt8(NULL);
      }
      ref1 = this.semanticTypes;
      for (i = j = 0, len1 = ref1.length; j < len1; i = j += 2) {
        typ = ref1[i];
        if (obj instanceof typ) {
          return this.semanticTypes[i + 1].call(this, this, obj);
        }
      }
      f = obj.encodeCBOR;
      if (typeof f === 'function') {
        return f.call(obj, this);
      }
      keys = Object.keys(obj);
      this._pushInt(keys.length, MT.MAP);
      results = [];
      for (l = 0, len2 = keys.length; l < len2; l++) {
        k = keys[l];
        this._pushAny(k);
        results.push(this._pushAny(obj[k]));
      }
      return results;
    };

    Encoder.prototype._pushAny = function(obj) {
      switch (typeof obj) {
        case 'number':
          return this._pushNumber(obj);
        case 'string':
          return this._pushString(obj);
        case 'boolean':
          return this._pushBoolean(obj);
        case 'undefined':
          return this._pushUndefined(obj);
        case 'object':
          return this._pushObject(obj);
        case 'symbol':
          switch (obj) {
            case SYMS.NULL:
              return this._pushObject(null);
            case SYMS.UNDEFINED:
              return this._pushUndefined(void 0);
            default:
              throw new Error('Unknown symbol: ' + obj.toString());
          }
        default:
          throw new Error('Unknown type: ' + typeof obj + ', ' + obj.toString());
      }
    };

    Encoder.encode = function() {
      var bs, enc, j, len1, o, objs;
      objs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      enc = new Encoder;
      bs = new NoFilter;
      enc.pipe(bs);
      for (j = 0, len1 = objs.length; j < len1; j++) {
        o = objs[j];
        switch (false) {
          case typeof o !== 'undefined':
            enc._pushUndefined();
            break;
          case !(o === null):
            enc._pushObject(null);
            break;
          default:
            enc.write(o);
        }
      }
      enc.end();
      return bs.read();
    };

    return Encoder;

  })(stream.Transform);

}).call(this);

//# sourceMappingURL=encoder.js.map
